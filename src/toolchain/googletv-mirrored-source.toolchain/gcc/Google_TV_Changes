Based on the following revisions:
GCC 4.5.3
GCC 4.5.2
diff -dur /tmp/tmp.HCVt7zvtt9/config/mt-gnu gcc/config/mt-gnu
--- /tmp/tmp.HCVt7zvtt9/config/mt-gnu	2011-05-03 23:51:48.000000000 -0700
+++ gcc/config/mt-gnu	2012-05-08 13:53:56.972248526 -0700
@@ -1 +1 @@
-CXXFLAGS_FOR_TARGET = $(CXXFLAGS) -D_GNU_SOURCE
+CXXFLAGS_FOR_TARGET += $(CXXFLAGS) -D_GNU_SOURCE
diff -dur /tmp/tmp.HCVt7zvtt9/gcc/ChangeLog gcc/gcc/ChangeLog
--- /tmp/tmp.HCVt7zvtt9/gcc/ChangeLog	2011-05-03 23:51:48.000000000 -0700
+++ gcc/gcc/ChangeLog	2012-05-08 13:53:57.002249069 -0700
@@ -1394,6 +1394,13 @@
 	* tree-vect-patterns.c (vect_recog_pow_pattern): Check that
 	FUNCTION_DECL exists and that it's a builtin.
 
+2010-12-03  Nathan Froyd  <froydnj@codesourcery.com>
+
+	* config/arm/arm.c (arm_legitimate_index_p): Split
+	VALID_NEON_QREG_MODE and VALID_NEON_DREG_MODE cases.  Permit
+	slightly larger constants in the latter case.
+	(thumb2_legitimate_index_p): Likewise.
+
 2010-12-03  Jason Merrill  <jason@redhat.com>
 
 	PR debug/46123
diff -dur /tmp/tmp.HCVt7zvtt9/gcc/config/arm/arm.c gcc/gcc/config/arm/arm.c
--- /tmp/tmp.HCVt7zvtt9/gcc/config/arm/arm.c	2011-05-03 23:51:48.000000000 -0700
+++ gcc/gcc/config/arm/arm.c	2012-05-08 13:53:57.452257214 -0700
@@ -5368,13 +5368,25 @@
 	    && INTVAL (index) > -1024
 	    && (INTVAL (index) & 3) == 0);
 
-  if (TARGET_NEON
-      && (VALID_NEON_DREG_MODE (mode) || VALID_NEON_QREG_MODE (mode)))
+  /* For quad modes, we restrict the constant offset to be slightly less
+     than what the instruction format permits.  We do this because for
+     quad mode moves, we will actually decompose them into two separate
+     double-mode reads or writes.  INDEX must therefore be a valid
+     (double-mode) offset and so should INDEX+8.  */
+  if (TARGET_NEON && VALID_NEON_QREG_MODE (mode))
     return (code == CONST_INT
 	    && INTVAL (index) < 1016
 	    && INTVAL (index) > -1024
 	    && (INTVAL (index) & 3) == 0);
 
+  /* We have no such constraint on double mode offsets, so we permit the
+     full range of the instruction format.  */
+  if (TARGET_NEON && VALID_NEON_DREG_MODE (mode))
+    return (code == CONST_INT
+           && INTVAL (index) < 1024
+           && INTVAL (index) > -1024
+           && (INTVAL (index) & 3) == 0);
+
   if (TARGET_REALLY_IWMMXT && VALID_IWMMXT_REG_MODE (mode))
     return (code == CONST_INT
 	    && INTVAL (index) < 1024
@@ -5488,13 +5500,25 @@
 		&& (INTVAL (index) & 3) == 0);
     }
 
-  if (TARGET_NEON
-      && (VALID_NEON_DREG_MODE (mode) || VALID_NEON_QREG_MODE (mode)))
+  /* For quad modes, we restrict the constant offset to be slightly less
+     than what the instruction format permits.  We do this because for
+     quad mode moves, we will actually decompose them into two separate
+     double-mode reads or writes.  INDEX must therefore be a valid
+     (double-mode) offset and so should INDEX+8.  */
+  if (TARGET_NEON && VALID_NEON_QREG_MODE (mode))
     return (code == CONST_INT
 	    && INTVAL (index) < 1016
 	    && INTVAL (index) > -1024
 	    && (INTVAL (index) & 3) == 0);
 
+  /* We have no such constraint on double mode offsets, so we permit the
+     full range of the instruction format.  */
+  if (TARGET_NEON && VALID_NEON_DREG_MODE (mode))
+    return (code == CONST_INT
+           && INTVAL (index) < 1024
+           && INTVAL (index) > -1024
+           && (INTVAL (index) & 3) == 0);
+
   if (arm_address_register_rtx_p (index, strict_p)
       && (GET_MODE_SIZE (mode) <= 4))
     return 1;
Only in gcc/gcc/config/arm: t-linux-gtveabi
diff -dur /tmp/tmp.HCVt7zvtt9/gcc/config/linux.h gcc/gcc/config/linux.h
--- /tmp/tmp.HCVt7zvtt9/gcc/config/linux.h	2011-05-03 23:51:48.000000000 -0700
+++ gcc/gcc/config/linux.h	2012-05-08 13:53:57.512258300 -0700
@@ -76,7 +76,9 @@
 #define LIB_SPEC \
   "%{pthread:-lpthread} \
    %{shared:-lc} \
-   %{!shared:%{mieee-fp:-lieee} %{profile:-lc_p}%{!profile:-lc}}"
+   %{!shared:%{mieee-fp:-lieee} \
+     %{profile:-lc_p %{static:-lnss_dns_p -lnss_files_p -lresolv_p}} \
+     %{!profile:-lc %{static:-lnss_dns -lnss_files -lresolv}}}"
 
 #define LINUX_TARGET_OS_CPP_BUILTINS()				\
     do {							\
diff -dur /tmp/tmp.HCVt7zvtt9/gcc/config.gcc gcc/gcc/config.gcc
--- /tmp/tmp.HCVt7zvtt9/gcc/config.gcc	2011-05-03 23:51:48.000000000 -0700
+++ gcc/gcc/config.gcc	2012-05-08 13:53:57.432256852 -0700
@@ -739,7 +739,9 @@
 	arm*-*-linux-*eabi)
 	    tm_file="$tm_file arm/bpabi.h arm/linux-eabi.h"
 	    tmake_file="$tmake_file arm/t-arm-elf arm/t-bpabi arm/t-linux-eabi t-slibgcc-libgcc"
-  	    # The BPABI long long divmod functions return a 128-bit value in
+	    tmake_file="$tmake_file arm/t-linux-gtveabi"
+
+	    # The BPABI long long divmod functions return a 128-bit value in
 	    # registers r0-r3.  Correctly modeling that requires the use of
 	    # TImode.
 	    need_64bit_hwint=yes
diff -dur /tmp/tmp.HCVt7zvtt9/gcc/cp/g++spec.c gcc/gcc/cp/g++spec.c
--- /tmp/tmp.HCVt7zvtt9/gcc/cp/g++spec.c	2011-05-03 23:51:48.000000000 -0700
+++ gcc/gcc/cp/g++spec.c	2012-05-08 13:53:57.662261015 -0700
@@ -100,7 +100,7 @@
   int static_link = 0;
 
   /* True if we should add -shared-libgcc to the command-line.  */
-  int shared_libgcc = 1;
+  int shared_libgcc = 0;
 
   /* The total number of arguments with the new stuff.  */
   int argc;
@@ -114,6 +114,9 @@
   /* The total number of arguments with the new stuff.  */
   int num_args = 1;
 
+  /* True if we saw -shared-libstdc++ */
+  int shared_libstdcpp = 0;
+
   argc = *in_argc;
   argv = *in_argv;
   added_libraries = *in_added_libraries;
@@ -203,13 +206,18 @@
 	    }
 	  else if (strcmp (argv[i], "-static") == 0)
 	    static_link = 1;
-	  else if (strcmp (argv[i], "-static-libgcc") == 0)
-	    shared_libgcc = 0;
+	  else if (strcmp (argv[i], "-shared-libgcc") == 0)
+	    shared_libgcc = 1;
 	  else if (strcmp (argv[i], "-static-libstdc++") == 0)
 	    {
 	      library = library >= 0 ? 2 : library;
 	      args[i] |= SKIPOPT;
 	    }
+	  else if (strcmp (argv[i], "-shared-libstdc++") == 0)
+	    {
+	      shared_libstdcpp = 1;
+	      args[i] |= SKIPOPT;
+	    }
 	  else if (DEFAULT_WORD_SWITCH_TAKES_ARG (&argv[i][1]))
 	    i++;
 	  else
@@ -326,6 +334,10 @@
       j++;
     }
 
+  /* Link libstdc++ statically by default */
+  if (library == 1 && !shared_libstdcpp)
+    library = 2;
+
   /* Add `-lstdc++' if we haven't already done so.  */
   if (library > 0)
     {
diff -dur /tmp/tmp.HCVt7zvtt9/gcc/gcc.c gcc/gcc/gcc.c
--- /tmp/tmp.HCVt7zvtt9/gcc/gcc.c	2011-05-03 23:51:48.000000000 -0700
+++ gcc/gcc/gcc.c	2012-05-08 13:53:57.792263368 -0700
@@ -1753,30 +1753,9 @@
 {
   char *buf;
 
-  buf = concat ("%{static|static-libgcc:", static_name, " ", eh_name, "}"
-		"%{!static:%{!static-libgcc:"
-#if USE_LD_AS_NEEDED
-		"%{!shared-libgcc:",
-		static_name, " --as-needed ", shared_name, " --no-as-needed"
-		"}"
-		"%{shared-libgcc:",
-		shared_name, "%{!shared: ", static_name, "}"
-		"}"
-#else
-		"%{!shared:"
-		"%{!shared-libgcc:", static_name, " ", eh_name, "}"
-		"%{shared-libgcc:", shared_name, " ", static_name, "}"
-		"}"
-#ifdef LINK_EH_SPEC
-		"%{shared:"
-		"%{shared-libgcc:", shared_name, "}"
-		"%{!shared-libgcc:", static_name, "}"
-		"}"
-#else
-		"%{shared:", shared_name, "}"
-#endif
-#endif
-		"}}", NULL);
+  buf = concat ("%{static|static-libgcc|!shared-libgcc:", static_name, " ", eh_name, "}"
+		"%{shared-libgcc:", shared_name, "%{!shared: ", static_name, "}"
+		"}", NULL);
 
   obstack_grow (obstack, buf, strlen (buf));
   free (buf);
@@ -2840,6 +2819,110 @@
 				file_at_path, &info);
 }
 
+/* Safe for overlapping strings */
+static inline char *
+strmove (char *dst, char *src)
+{
+  char *res = dst;
+  while ((*dst++ = *src++)) ;
+  return res;
+}
+
+/* Normalize path by removing //, .. and .
+ * Symlinks are not resolved, and path is not checked to exist.
+ */
+static const char*
+normalize_path (const char *prefix)
+{
+  char ch, *p, *res, *path;
+  enum {
+    ST_EMPTY,
+    ST_DOT,
+    ST_DOT_DOT,
+    ST_OTHER
+  } state;
+
+  res = path = xstrdup (prefix);
+
+  /* Normalize slashes first */
+  p = path;
+  while ((ch = *p++))
+    if (ch == '/')
+      {
+        char *pp = p;
+        while (*pp == '/')
+          ++pp;
+        if (pp != p)
+          strmove(p, pp);
+      }
+
+  /* Remove '.' and '..' */
+  p = path;
+  state = ST_EMPTY;
+  while ((ch = *p))
+    {
+      switch (ch)
+        {
+        case '.':
+          if (state < ST_OTHER)
+            ++state;
+          ++p;
+          break;
+
+        case '/':
+          switch (state)
+            {
+            case ST_DOT:
+              p = strmove(p - 1, p + 1);
+              break;
+
+            case ST_DOT_DOT:
+              if (p - path > 3)
+                {
+                  char *pp = p - 4;
+                  while (pp >= path && *pp != '/')
+                    --pp;
+                  p = strmove(pp + 1, p + 1);
+                }
+              else
+                path = p++;
+              break;
+
+            default:
+              ++p;
+            }
+          state = ST_EMPTY;
+          break;
+
+         default:
+           state = ST_OTHER;
+           ++p;
+         }
+    }
+
+  switch (state)
+    {
+    case ST_DOT:
+      p[-1] = '\0';
+      break;
+
+    case ST_DOT_DOT:
+      if (p - path > 3)
+        {
+          char *pp = p - 4;
+          while (pp >= path && *pp != '/')
+            --pp;
+          pp[1] = '\0';
+        }
+      break;
+    default:
+      ;
+    }
+
+  return res;
+}
+
+
 /* Ranking of prefixes in the sort list. -B prefixes are put before
    all others.  */
 
@@ -2876,8 +2959,9 @@
        prev = &(*prev)->next)
     ;
 
-  /* Keep track of the longest prefix.  */
+  prefix = normalize_path(prefix);
 
+  /* Keep track of the longest prefix.  */
   prefix = update_path (prefix, component);
   len = strlen (prefix);
   if (len > pprefix->max_len)
diff -dur /tmp/tmp.HCVt7zvtt9/gcc/testsuite/ChangeLog gcc/gcc/testsuite/ChangeLog
--- /tmp/tmp.HCVt7zvtt9/gcc/testsuite/ChangeLog	2011-05-03 23:51:48.000000000 -0700
+++ gcc/gcc/testsuite/ChangeLog	2012-05-08 13:53:58.042267893 -0700
@@ -774,6 +774,10 @@
 	PR fortran/46794
 	* gfortran.dg/power2.f90: New test.
 
+2010-12-03  Nathan Froyd  <froydnj@codesourcery.com>
+
+	* gcc.target/arm/neon-offset-1.c: New test.
+
 2010-12-03  Jakub Jelinek  <jakub@redhat.com>
 
 	PR debug/46123
Only in gcc/gcc/testsuite/gcc.target/arm: neon-offset-1.c
